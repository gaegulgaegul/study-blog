# 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용되는지(자기사용) 문서로 남겨야 한다.
    - 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
    - @ImplSpec
        - 상속할 경우 메서드의 내부 동작을 설명한다.
        - 해당 태그를 메서드 주석에 붙이면 자바독 도구가 생성해준다.
        - 자바 8에서 추가되었다.
- 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수 있다.
    - protected 메서드는 내부 구현에 해당하여 수가 적어야 한다.
    - 어떤 메서드를 protected로 노출할지 정하는 것은 하위 클래스를 만들어 시험해보는 것이 최선이다.
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.
    - 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않은 proected 멤버는 private로 있어야할 가능성이 크다.
    - 하위 클래스는 3개 정도 만들어보는 것이 적당하다.
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.
    - 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.

    ```java
    public class Super {
        // 잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다.
        public Super() {
            overrideMe();
        }

        public void overrideMe() {

        }
    }

    public class Sub extends Super {
        // 초기화되지 않은 final 필드. 생성자에서 초기화한다.
        private final Instant instant;

        public Sub() {
            this.instant = Instant.now();
        }

        // 재정의 가능 메서드. 상위 클래스의 생성자가 호출한다.
        @Override
        public void overrideMe() {
            // 상위 클래스의 생성자가 호출 시 NullPointerException이 발생한다.
            System.out.println(instant);
        }

        public static void main(String[] args) {
            Sub sub = new Sub();
            sub.overrideMe();
        }
    }

    ===
    null // println은 null을 출력하여 에러가 발생하지 않았다.
    2021-08-16T14:00:49.067094Z
    ```

- clone과 readObject 모두 재정의 가능 메서드를 호출해서는 안 된다.
- Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 private이 아니라 protected로 선언해야 한다.
- 상속용 클래스를 설계하지 않고 상속을 금지하는 것이 가장 좋은 방법이다.
    - 핵심 기능을 정의한 인터페이스가 있고, 클래스가 인터페이스를 구현했다면 상속을 하지 않아도 문제가 없다.
- 구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기 불편하다.
    - 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 문서로 남긴다.
    - 재정의 가능 메서드를 호출하는 자기 사용 코드를 완벽하게 제거해야 한다.